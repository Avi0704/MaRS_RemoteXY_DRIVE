/*
   -- New project --
   
   To compile this code using RemoteXY library 4.1.4 or later version 
   download by link http://remotexy.com/en/library/
   To connect using RemoteXY mobile app by link http://remotexy.com/en/download/                   
     - for ANDROID 4.16.02 or later version;
     - for iOS 1.13.1 or later version;
    
   To interact with the GUI, please refer to the manual: 
   https://remotexy.com/ru/help/code/interaction/

   This source code was automatically generated by the RemoteXY editor and 
   is an example for the RemoteXY library. 
   Licensed under the MIT License. See the LICENSE file in the RemoteXY library
   root (https://github.com/RemoteXY/RemoteXY-Arduino-library) for full license 
   details.             

   ---
   Rover logic for Cytron MD10C merged by Gemini
   - slider_01: Speed
   - joystick_01_y: Direction
   - pushSwitch_01: Toggle Spot Turn Mode
*/

//////////////////////////////////////////////
// Driver mode: CYTRON (MD10C)
//////////////////////////////////////////////
#define DRIVER_MODE_CYTRON

//////////////////////////////////////////////
//        RemoteXY include library          //
//////////////////////////////////////////////

// you can enable debug logging to Serial at 115200
//#define REMOTEXY__DEBUGLOG    

// RemoteXY select connection mode and include library 
#define REMOTEXY_MODE__WIFI_POINT

#include <WiFi.h>

// RemoteXY connection settings 
#define REMOTEXY_WIFI_SSID "Remote12XY"
#define REMOTEXY_WIFI_PASSWORD "12345678"
#define REMOTEXY_SERVER_PORT 6377
#define REMOTEXY_ACCESS_PASSWORD "12345678"


#include <RemoteXY.h>

// RemoteXY GUI configuration (New 76 bytes)
#pragma pack(push, 1)  
uint8_t RemoteXY_CONF[] =   // 76 bytes
  { 255,4,0,5,0,69,0,19,0,0,0,75,65,80,73,0,31,1,200,84,
  1,1,5,0,10,91,6,24,24,48,4,26,31,79,78,0,31,79,70,70,
  0,70,67,6,18,18,16,26,37,0,4,21,11,18,55,0,2,26,67,67,
  50,40,10,78,2,26,2,5,132,13,60,60,16,2,26,31 };
  
// this structure defines all the variables and events of your control interface 
struct {

    // input variables
  uint8_t pushSwitch_01; // =1 if state is ON, else =0. NOW USED FOR SPOT TURN TOGGLE
  int8_t slider_01; // from 0 to 100 (Speed)
  int8_t joystick_01_x; // from -100 to 100 (Ignored)
  int8_t joystick_01_y; // from -100 to 100 (Direction)

    // output variables
  uint8_t led_01; // from 0 to 1 (Driving Status)
  float value_01; // PWM Value Display

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;   
#pragma pack(pop)
 
/////////////////////////////////////////////
//           END RemoteXY include          //
/////////////////////////////////////////////

//////////////////////////////////////////////
// Pins — DIR + PWM per wheel (edit if needed)
//////////////////////////////////////////////
#define DIR_FL  4
#define PWM_FL 16
#define DIR_FR 17
#define PWM_FR  5
#define DIR_BL 18
#define PWM_BL 19
#define DIR_BR 21
#define PWM_BR 22

// LEDC setup (high freq for MD10C)
#define CH_FL 0
#define CH_FR 1
#define CH_BL 2
#define CH_BR 3
#define PWM_FREQ 20000    // 20 kHz (quiet, MD10C-friendly)
#define PWM_RES  8        // 0..255

// Debug (optional)
#define DEBUG_BAUD 115200

//////////////////////////////////////////////
// Motor helper for Cytron MD10C
//////////////////////////////////////////////
class MotorCytron {
public:
  MotorCytron(int dir, int pwm, int ch) : dir_pin(dir), pwm_pin(pwm), channel(ch) {}
  void begin() {
    pinMode(dir_pin, OUTPUT);
    ledcSetup(channel, PWM_FREQ, PWM_RES);
    ledcAttachPin(pwm_pin, channel);
    stop();
  }
  void setFwdPolarity(bool forward_is_high){ fwdHigh = forward_is_high; }
  void forward(){ digitalWrite(dir_pin, fwdHigh ? HIGH : LOW); }
  void backward(){ digitalWrite(dir_pin, fwdHigh ? LOW  : HIGH); }
  void write(uint8_t d){ ledcWrite(channel, d); }
  void stop(){ write(0); }
private:
  int dir_pin, pwm_pin, channel;
  bool fwdHigh = true; // MD10C: typically HIGH = forward; flip per wheel if needed
};

MotorCytron M_FL(DIR_FL, PWM_FL, CH_FL);
MotorCytron M_FR(DIR_FR, PWM_FR, CH_FR);
MotorCytron M_BL(DIR_BL, PWM_BL, CH_BL);
MotorCytron M_BR(DIR_BR, PWM_BR, CH_BR);

static uint8_t g_pwm = 0;    // 0..255
static bool driving = false;  // command state

// --- Motor Control Helpers ---
inline void allForward(){ M_FL.forward(); M_FR.forward(); M_BL.forward(); M_BR.forward(); }
inline void allBackward(){M_FL.backward();M_FR.backward();M_BL.backward();M_BR.backward(); }
inline void allPWM(uint8_t d){ M_FL.write(d); M_FR.write(d); M_BL.write(d); M_BR.write(d); }
inline void allStop(){ M_FL.stop(); M_FR.stop(); M_BL.stop(); M_BR.stop(); }

// --- Spot Turn Helpers ---
// Spot Turn Right (Clockwise): Left fwd, Right back
inline void spotTurnRight() {
  M_FL.forward(); M_BL.forward();
  M_FR.backward(); M_BR.backward();
}
// Spot Turn Left (Counter-Clockwise): Left back, Right fwd
inline void spotTurnLeft() {
  M_FL.backward(); M_BL.backward();
  M_FR.forward(); M_BR.forward();
}


void setup() 
{
  RemoteXY_Init (); 
  
  // Rover setup code
  Serial.begin(DEBUG_BAUD);

  M_FL.begin(); M_FR.begin(); M_BL.begin(); M_BR.begin();

  // If any wheel’s “forward” is reversed, flip just that wheel here:
  M_FL.setFwdPolarity(true);   // HIGH = forward (typical)
  M_FR.setFwdPolarity(true);
  M_BL.setFwdPolarity(true);
  M_BR.setFwdPolarity(true);

  g_pwm = 0; driving = false;
  RemoteXY.value_01 = 0;
  RemoteXY.led_01 = 0;

  Serial.println("MD10C mode ready. Spot turn on pushSwitch_01.");
}

void loop() 
{ 
  RemoteXY_Handler ();
  
  // Debug UI input (every 500 ms)
  static uint32_t t = 0;
  if (millis() - t > 500) {
    t = millis();
    // Updated Serial print for new logic
    Serial.printf("conn=%u spot_mode=%u speed=%d joyY=%d -> pwm=%u drive=%u\n",
      RemoteXY.connect_flag, RemoteXY.pushSwitch_01,
      (int)RemoteXY.slider_01, (int)RemoteXY.joystick_01_y,
      g_pwm, driving);
  }

  // --- NO MORE KILL SWITCH ---
  // pushSwitch_01 is now for spot turn mode

  // Speed 0..100 -> 0..255
  uint8_t target_pwm = map(constrain((int)RemoteXY.slider_01, 0, 100), 0, 100, 0, 255);

  // Direction from joystick Y
  const int deadband = 8;
  int jy = constrain((int)RemoteXY.joystick_01_y, -100, 100);

  // === NEW LOGIC with Spot Turn Mode on pushSwitch_01 ===
  if (RemoteXY.pushSwitch_01 == 1) {
    // --- SPOT TURN MODE ---
    if (target_pwm == 0 || abs(jy) <= deadband) {
      // Stop
      g_pwm = 0;
    } else if (jy > deadband) {
      // Spot Turn Right (joystick up)
      spotTurnRight();
      g_pwm = target_pwm;
    } else { // jy < -deadband
      // Spot Turn Left (joystick down)
      spotTurnLeft();
      g_pwm = target_pwm;
    }

  } else {
    // --- NORMAL 4WD MODE ---
    if (target_pwm == 0 || abs(jy) <= deadband) {
      // Stop
      g_pwm = 0;
    } else if (jy > deadband) {
      // Forward
      allForward();
      g_pwm = target_pwm;
    } else { // jy < -deadband
      // Backward
      allBackward();
      g_pwm = target_pwm;
    }
  }
  // === END NEW LOGIC ===


  // Apply the calculated PWM to all motors
  if (g_pwm == 0) {
    allStop();
  } else {
    allPWM(g_pwm);
  }
  
  // Update the 'driving' state *after* the logic, based on the result.
  driving = (g_pwm > 0);

  // Update RemoteXY outputs
  RemoteXY.value_01 = (float)g_pwm;      // update display
  RemoteXY.led_01 = driving ? 1 : 0;     // Use new led_01 for status

  RemoteXY_delay(5);
}
