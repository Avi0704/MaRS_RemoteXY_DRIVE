/*
   -- New project --
   
   To compile this code using RemoteXY library 4.1.4 or later version 
   download by link http://remotexy.com/en/library/
   To connect using RemoteXY mobile app by link http://remotexy.com/en/download/                   
     - for ANDROID 4.16.02 or later version;
     - for iOS 1.13.1 or later version;
    
   To interact with the GUI, please refer to the manual: 
   https://remotexy.com/ru/help/code/interaction/

   This source code was automatically generated by the RemoteXY editor and 
   is an example for the RemoteXY library. 
   Licensed under the MIT License. See the LICENSE file in the RemoteXY library
   root (https://github.com/RemoteXY/RemoteXY-Arduino-library) for full license 
   details.             
   
   ---
   Rover Basic Control Logic for Cytron MD10C
   - slider_01: Speed control (PWM 0-255)
   - value_01: Displays current PWM value
   - Fixed Direction: Forward (simplest implementation based on request)
*/

//////////////////////////////////////////////
// Driver mode: CYTRON (MD10C)
//////////////////////////////////////////////
#define DRIVER_MODE_CYTRON

//////////////////////////////////////////////
//        RemoteXY include library          //
//////////////////////////////////////////////

// you can enable debug logging to Serial at 115200
//#define REMOTEXY__DEBUGLOG    

// RemoteXY select connection mode and include library 
#define REMOTEXY_MODE__WIFI_POINT

#include <WiFi.h>

// RemoteXY connection settings 
#define REMOTEXY_WIFI_SSID "RemoteXY"
#define REMOTEXY_WIFI_PASSWORD "12345678"
#define REMOTEXY_SERVER_PORT 6377
#define REMOTEXY_ACCESS_PASSWORD "12345678"


#include <RemoteXY.h>

// RemoteXY GUI configuration (User provided - 67 bytes) 
#pragma pack(push, 1)  
uint8_t RemoteXY_CONF[] =   // 67 bytes
  { 255,4,0,4,0,60,0,19,0,0,0,75,65,80,73,0,31,1,200,84,
  1,1,4,0,10,79,10,24,24,48,4,26,31,79,78,0,31,79,70,70,
  0,4,21,11,18,55,0,2,26,67,67,50,40,10,78,2,26,2,5,132,
  13,60,60,16,2,26,31 };
  
// this structure defines all the variables and events of your control interface 
struct {

    // input variables
  uint8_t pushSwitch_01; // =1 if state is ON, else =0, from 0 to 1
  int8_t slider_01; // from 0 to 100 (Speed Input)
  int8_t joystick_01_x; // from -100 to 100
  int8_t joystick_01_y; // from -100 to 100

    // output variables
  float value_01; // PWM Value Display (0-255)

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0

} RemoteXY;   
#pragma pack(pop)
 
/////////////////////////////////////////////
//           END RemoteXY include          //
/////////////////////////////////////////////


//////////////////////////////////////////////
// Pins â€” DIR + PWM per wheel (MD10C)
//////////////////////////////////////////////
#define DIR_FL  4
#define PWM_FL 16
#define DIR_FR 17
#define PWM_FR  5
#define DIR_BL 18
#define PWM_BL 19
#define DIR_BR 21
#define PWM_BR 22

// LEDC setup (high freq for MD10C on ESP32)
#define CH_FL 0
#define CH_FR 1
#define CH_BL 2
#define CH_BR 3
#define PWM_FREQ 20000     // 20 kHz (quiet, MD10C-friendly)
#define PWM_RES  8         // 0..255 resolution

// Debug (optional)
#define DEBUG_BAUD 115200

//////////////////////////////////////////////
// Motor helper for Cytron MD10C
//////////////////////////////////////////////
class MotorCytron {
public:
  MotorCytron(int dir, int pwm, int ch) : dir_pin(dir), pwm_pin(pwm), channel(ch) {}
  void begin() {
    pinMode(dir_pin, OUTPUT);
    // Setup LEDC channel for PWM
    ledcSetup(channel, PWM_FREQ, PWM_RES);
    ledcAttachPin(pwm_pin, channel);
    stop();
  }
  void setFwdPolarity(bool forward_is_high){ fwdHigh = forward_is_high; }
  // Set Direction pin for Forward
  void forward(){ digitalWrite(dir_pin, fwdHigh ? HIGH : LOW); }
  // Set Direction pin for Backward
  void backward(){ digitalWrite(dir_pin, fwdHigh ? LOW  : HIGH); }
  // Set PWM duty cycle (0-255)
  void write(uint8_t d){ ledcWrite(channel, d); }
  // Stop the motor (PWM = 0)
  void stop(){ write(0); }
private:
  int dir_pin, pwm_pin, channel;
  bool fwdHigh = true; // MD10C: typically HIGH = forward
};

// Instantiate all four motors
MotorCytron M_FL(DIR_FL, PWM_FL, CH_FL); // Front-Left
MotorCytron M_FR(DIR_FR, PWM_FR, CH_FR); // Front-Right
MotorCytron M_BL(DIR_BL, PWM_BL, CH_BL); // Back-Left
MotorCytron M_BR(DIR_BR, PWM_BR, CH_BR); // Back-Right

static uint8_t g_pwm = 0;     // Global PWM value (0..255)

// --- Motor Control Helpers ---
// Set all motors to forward direction
inline void allForward(){ M_FL.forward(); M_FR.forward(); M_BL.forward(); M_BR.forward(); }
// Set all motors to backward direction
inline void allBackward(){M_FL.backward();M_FR.backward();M_BL.backward();M_BR.backward(); }
// Set PWM value for all motors
inline void allPWM(uint8_t d){ M_FL.write(d); M_FR.write(d); M_BL.write(d); M_BR.write(d); }
// Stop all motors
inline void allStop(){ M_FL.stop(); M_FR.stop(); M_BL.stop(); M_BR.stop(); }


void setup() 
{
  RemoteXY_Init (); 
  
  // Rover setup code
  Serial.begin(DEBUG_BAUD);

  // Initialize all motor drivers
  M_FL.begin(); M_FR.begin(); M_BL.begin(); M_BR.begin();

  // Set the default polarity (HIGH for forward). Change to false if motor wiring requires it.
  M_FL.setFwdPolarity(true);
  M_FR.setFwdPolarity(true);
  M_BL.setFwdPolarity(true);
  M_BR.setFwdPolarity(true);

  g_pwm = 0; 
  RemoteXY.value_01 = 0.0;
  
  // Set the default direction to Forward since we only use the slider for speed
  allForward(); 
  
  Serial.println("MD10C Basic Control ready. Slider controls forward speed.");
}

void loop() 
{ 
  RemoteXY_Handler ();
  
  
  // 1. Read speed input from the slider (0-100)
  int slider_value = constrain((int)RemoteXY.slider_01, 0, 100);

  // 2. Map the slider value (0-100) to the full PWM range (0-255)
  // This is the target PWM magnitude
  uint8_t target_pwm = map(slider_value, 0, 100, 0, 255);
  g_pwm = target_pwm;

  // 3. Apply the PWM
  if (g_pwm == 0) {
    allStop();
  } else {
    // The direction was preset to allForward() in setup, so we just apply PWM
    allPWM(g_pwm);
  }
  
  // 4. Update RemoteXY output variable
  RemoteXY.value_01 = (float)g_pwm;      // Display the current PWM value (0-255)

  // Optional: Debug print every half second
  static uint32_t t = 0;
  if (millis() - t > 500) {
    t = millis();
    Serial.printf("conn=%u slider=%d -> pwm=%u\n",
      RemoteXY.connect_flag, (int)RemoteXY.slider_01, g_pwm);
  }
  
  RemoteXY_delay(5);
}
